<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-04-22T01:02:14.187Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux_01</title>
    <link href="http://yoursite.com/2018/04/21/linux-01/"/>
    <id>http://yoursite.com/2018/04/21/linux-01/</id>
    <published>2018-04-21T14:57:34.000Z</published>
    <updated>2018-04-22T01:02:14.187Z</updated>
    
    <content type="html"><![CDATA[<p>#linux文件系统命令</p><pre><code>1.  ls ：显示目录文件ls 选项或目录</code></pre><p><img src="http://i1.bvimg.com/642093/376eaf3ca037577cs.png" alt="Markdown"></p><pre><code>2.  ls -l   :显示详情</code></pre><p><img src="http://i1.bvimg.com/642093/3de439e196bfdf88.png" alt="Markdown"></p><pre><code>3.  cd :切换目录 cd [目录名] cd /   切换回根目录 cd ..   回到上一级目录</code></pre><p><img src="http://i1.bvimg.com/642093/865b9df3f93fc7c5s.png" alt="Markdown"></p><pre><code>4. 命令前的中括号里是所在路径，当前所在路径也可以用pwd查询</code></pre><p><img src="http://i1.bvimg.com/642093/453115c41a87d7aes.png" alt="Markdown"></p><pre><code>5.  touch [文件名] ：创建空文件</code></pre><p><img src="http://i1.bvimg.com/642093/099c476a260aef4bs.png" alt="Markdown"><br>    创建完就可以使用 ls 查询到了</p><pre><code>6.  mkdir [目录名]  ：创建空目录</code></pre><p><img src="http://i1.bvimg.com/642093/f33d8a23ae046e43s.png" alt="Markdown"></p><pre><code>7.  cp 文件名1 文件名2  …  目录名 将1个或n个文件复制到目录下 8.  cp -r 目录1 文件1 …  目录名 将n个目录中的内容或者文件复制到目录下</code></pre><p><img src="http://i1.bvimg.com/642093/3f830095527ed83bs.png" alt="Markdown"><br>     mv ：移动或更名<br>     mv file1 file2 :将file1更名为file2<br>     mv file1 dir  :将文件或目录移动到dir下<br>     仔细观察mv操作：<br><img src="http://i1.bvimg.com/642093/cd83eb88ce01cd11s.png" alt="Markdown"></p><pre><code>10.  rm file2  删除文件file2  rm –r dir1  删除目录dir1 </code></pre><p><img src="http://i1.bvimg.com/642093/16d4d731e9d8b0efs.png" alt="Markdown"></p><pre><code>11.  cat [文件名] ：显示文件内容 cat /etc/issue  cat /etc/services  执行：cat /etc/services</code></pre><p><img src="http://i1.bvimg.com/642093/280fad2b2968cc55s.png" alt="Markdown"><br>         more [文件名]<br>     (空格)或f 显示下一页<br>     (enter) 显示下一行<br>     q或Q 退出 </p><pre><code>13. head -num [文件名]  -num 显示文件的前num行</code></pre><p><img src="http://i1.bvimg.com/642093/8d80a9d3d5ca6b8es.png" alt="Markdown"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#linux文件系统命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.  ls ：显示目录文件
ls 选项或目录
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;img src=&quot;http://i1.bvimg.com/642093/376eaf3ca037577cs.png&quot; alt=&quot;Mark
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java_02</title>
    <link href="http://yoursite.com/2018/04/18/java-02/"/>
    <id>http://yoursite.com/2018/04/18/java-02/</id>
    <published>2018-04-18T15:08:36.000Z</published>
    <updated>2018-04-18T15:09:51.133Z</updated>
    
    <content type="html"><![CDATA[<p>#多态之向上造型类型</p><pre><code>解释：`属性是绑定到变量上（只能调用父类中有的属性），重写方法是动态绑定到对象上`</code></pre><p>A a = new B();//a 变量，B是对象</p><p><img src="http://i4.bvimg.com/642093/b5d69cb27f7c41b1.png" alt="Markdown"></p><pre><code>从图中我们可以看出,变量a所能引用的属性只有A中的属性，B中的属性不出现在a可以引用的列表中此即属性是（静态）绑定到对象变量上的</code></pre><p><img src="http://i4.bvimg.com/642093/62691f4247d5d8d2.png" alt="Markdown"></p><pre><code>从图中我们可以看出，此时类B重写了方法printS();执行过程如下啊：编译时，引用的是A中的printS();但在运行时，发现B中重写了方法,于是就用B中的方法覆盖了A中的方法。如下：</code></pre><p><img src="http://i4.bvimg.com/642093/62691f4247d5d8d2.png" alt="Markdown"></p><pre><code>此即方法时动态绑定到对象上的。如若想引用B类中的属性，该如何操作呢？见下图：将a强制转换为B类型即可。</code></pre><p><img src="http://i4.bvimg.com/642093/73890ce45eb48326s.png" alt="Markdown"></p><pre><code>但是我们会发现</code></pre><p><img src="http://i4.bvimg.com/642093/c434a045ac96abafs.png" alt="Markdown"></p><pre><code>强制转换为C类型也不会报错，这是因为在编译期间，编译器只检查语法错误。现在我们运行一下：</code></pre><p><img src="http://i4.bvimg.com/642093/843152555e3ef537s.png" alt="Markdown"></p><pre><code>发现报了ClassCastException错误。为了避免类似的错误发生我们使用如下方法进行改善代码：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Coo();</span><br><span class="line">      if(a instanceof Boo)&#123;</span><br><span class="line">            Boo  b = (Boo)a; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><pre><code>instanceof就是判断变量所指的对象是不是某一类型。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#多态之向上造型类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;解释：
`属性是绑定到变量上（只能调用父类中有的属性），重写方法是动态绑定到对象上`
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;A a = new B();//a 变量，B是对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i4
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java_01</title>
    <link href="http://yoursite.com/2018/04/18/java-01/"/>
    <id>http://yoursite.com/2018/04/18/java-01/</id>
    <published>2018-04-17T16:16:14.000Z</published>
    <updated>2018-04-17T16:17:38.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的特征（后续会贴详细代码）"><a href="#面向对象的特征（后续会贴详细代码）" class="headerlink" title="面向对象的特征（后续会贴详细代码）"></a>面向对象的特征（后续会贴详细代码）</h1><pre><code>面向对象有三大特征：继承，封装，多态。今天我就来详细介绍一下面向对象这三个特征，着重记一下各个特征的优缺点</code></pre><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><pre><code>java语言支持单继承，一个类可以继承一个父类这样，父类里的方法及属性，被子类继承，有利于程序的功能扩展为了开发方便好处：可以不用修改一个类，利用继承的特点，可以扩展这个类，生成一个子类，有利于二次开发优点：增加代码重用性，有利于类的功能扩展，也保证了父类的安全性</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class new A()&#123;</span><br><span class="line">    public A()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h2><pre><code>将属性/方法封装到类里，将一段逻辑封装到方法里好处：提高代码的重用性，减少冗余，减少代码的可见性，相对安全</code></pre><h2 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h2><pre><code>对象的多态：不同父类型的引用指向同一个对象，会有不同的行为功能变量的多态：同一个变量指向不同的对象时，会有不同的行为好处:在使用代码时更方便，有利于程序的修改</code></pre><h3 id="向上造型"><a href="#向上造型" class="headerlink" title="向上造型"></a>向上造型</h3><pre><code>父类型的变量指向子类型的对象在编译期间，变量调用的方法是父类型中的。在运行期间, 如果调用的方法子类重写了，那么一定是重写后的方法如果没重写，那么调用的是父类中的方法变量调用的属性：一定是父类中的属性 总结：`属性是绑定到变量上（只能调用父类中有的属性），重写方法是动态绑定到对象上`。属性看变量类型，方法看对象类型向下转型：将父类型的变量，转换子类型的变量</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Boo();//a是变量，Book（）是对象</span><br><span class="line">Boo  b = (Boo)a;</span><br></pre></td></tr></table></figure><p>有可能会出现ClassCastException:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Coo();</span><br><span class="line">Boo  b = (Boo)a;</span><br></pre></td></tr></table></figure></p><p>编译期间：javac.exe只检查代码的语法是否正确。<br>此处语法虽然正确，但是a的类型并不是<br>为了避免这种情况发生，需要使用 instanceof进行判断，<br>判断变量所指的对象是不是某一类型。<br>上述代码应该改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Coo();</span><br><span class="line">if(a instanceof Boo)&#123;</span><br><span class="line">    Boo  b = (Boo)a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象的特征（后续会贴详细代码）&quot;&gt;&lt;a href=&quot;#面向对象的特征（后续会贴详细代码）&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特征（后续会贴详细代码）&quot;&gt;&lt;/a&gt;面向对象的特征（后续会贴详细代码）&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;面向
      
    
    </summary>
    
    
  </entry>
  
</feed>
