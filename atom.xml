<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-03T16:24:02.148Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>nanyaonan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux_01</title>
    <link href="http://yoursite.com/2018/04/21/linux-01/"/>
    <id>http://yoursite.com/2018/04/21/linux-01/</id>
    <published>2018-04-21T14:57:34.000Z</published>
    <updated>2018-05-03T16:24:02.148Z</updated>
    
    <content type="html"><![CDATA[<h1 id="linux文件系统命令"><a href="#linux文件系统命令" class="headerlink" title="linux文件系统命令"></a>linux文件系统命令</h1><pre><code>1.  ls ：显示目录文件ls 选项或目录</code></pre><p><img src="\image\linux_01\11.png" alt="avatar"></p><pre><code>2.  ls -l   :显示详情</code></pre><p><img src="\image\linux_01\12.png" alt="avatar"></p><pre><code>3.  cd :切换目录 cd [目录名] cd /   切换回根目录 cd ..   回到上一级目录</code></pre><p><img src="\image\linux_01\13.png" alt="avatar"></p><pre><code>4. 命令前的中括号里是所在路径，当前所在路径也可以用pwd查询</code></pre><p><img src="\image\linux_01\14.png" alt="avatar"></p><pre><code>5.  touch [文件名] ：创建空文件</code></pre><p><img src="\image\linux_01\15.png" alt="avatar"><br>    创建完就可以使用 ls 查询到了</p><pre><code>6.  mkdir [目录名]  ：创建空目录</code></pre><p><img src="\image\linux_01\16.png" alt="avatar"></p><pre><code>7.  cp 文件名1 文件名2  …  目录名 将1个或n个文件复制到目录下 8.  cp -r 目录1 文件1 …  目录名 将n个目录中的内容或者文件复制到目录下</code></pre><p><img src="\image\linux_01\17.png" alt="avatar"><br>     mv ：移动或更名<br>     mv file1 file2 :将file1更名为file2<br>     mv file1 dir  :将文件或目录移动到dir下<br>     仔细观察mv操作：<br><img src="\image\linux_01\18.png" alt="avatar"></p><pre><code>10.  rm file2  删除文件file2  rm –r dir1  删除目录dir1 </code></pre><p><img src="\image\linux_01\19.png" alt="avatar">)</p><pre><code>11.  cat [文件名] ：显示文件内容 cat /etc/issue  cat /etc/services  执行：cat /etc/services</code></pre><p><img src="\image\linux_01\20.png" alt="avatar"><br>         more [文件名]<br>     (空格)或f 显示下一页<br>     (enter) 显示下一行<br>     q或Q 退出 </p><pre><code>13. head -num [文件名]  -num 显示文件的前num行</code></pre><p><img src="\image\linux_01\21.png" alt="avatar"></p><pre><code>14.  tail -num [文件名]显示文件的后num行15. ln -s [源文件] [目标文件]  -s 创建软连接 Ex: ln –s /etc/issue /issue.soft  创建文件/etc/issue的软连接/issue.soft  ln /etc/issue /issue.hard  创建文件/etc/issue的硬链接/issue.运行命令：ln -s /etc/issue /issue.soft此时可能会提醒：权限不够这是我们有两种解决方案：1.进入到root权限下；然后运行该语句 </code></pre><p><img src="\image\linux_01\22.png" alt="avatar"><br>    2.使用下面一个命令修改权限</p><pre><code>16. 权限管理命令： chmod :改变权限 chmod [{ugo}{+-=}{rwx}] [文件或目录]         [421] [文件或目录] eg： chmod [ugo+-=rwx] 文件或目录              777首先：输入ll命令查看权限：</code></pre><p><img src="\image\linux_01\23.png" alt="avatar"><br><img src="\image\linux_01\24.png" alt="avatar"></p><pre><code>234位表示root权限，567位表示拥有者（创建该文件的用户）的权限，最后三位表示其它组成员的权限。比如，我这个虚拟机除了root 还有nanyaonan和scott这两个用户rwx分别表示可读可写可执行。命令中 u 代表root的权限，g代表本组权限，o代表其他组的权限</code></pre><p><img src="\image\linux_01\25.png" alt="avatar"><br>    可以看见helloword的user权限已经被改变<br>    另外r = 4 w =2 x = 1对应上面的mode形式 chmod 764 helloword和上边的语法效果相同<br><img src="\image\linux_01\26.png" alt="avatar"></p><pre><code>17. 文件目录权限总结</code></pre><p><img src="\image\linux_01\27.png" alt="avatar"></p><pre><code>18. 改变所有者chown [用户] [文件或目录] Ex：chown nobody file1  改变文件file1的所有者为nobody 19.  chgrp:改变所属组chgrp [用户组] [文件或目录] Ex: chgrp adm file1  改变文件file1的所属组为adm 20.  umask:查看系统默认的权限直接使用umask：显示的是 0022 ，想得到真正的权限，应该用777去解码（777-022得到的数字即为权限），第一个0是特殊权限umask [-S]  -S 以rwx形式显示新建文件或目录的缺省权限 Ex: umask  umask -S</code></pre><p><img src="\image\linux_01\28.png" alt="avatar"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;linux文件系统命令&quot;&gt;&lt;a href=&quot;#linux文件系统命令&quot; class=&quot;headerlink&quot; title=&quot;linux文件系统命令&quot;&gt;&lt;/a&gt;linux文件系统命令&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1.  ls ：显示目录文件
ls 选项或目录
&lt;/
      
    
    </summary>
    
      <category term="linux" scheme="http://yoursite.com/categories/linux/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java_02</title>
    <link href="http://yoursite.com/2018/04/18/java-02/"/>
    <id>http://yoursite.com/2018/04/18/java-02/</id>
    <published>2018-04-18T15:08:36.000Z</published>
    <updated>2018-05-01T14:04:50.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多态之向上造型类型"><a href="#多态之向上造型类型" class="headerlink" title="多态之向上造型类型"></a>多态之向上造型类型</h1><pre><code>解释：`属性是绑定到变量上（只能调用父类中有的属性），重写方法是动态绑定到对象上`</code></pre><p>A a = new B();//a 变量，B是对象</p><p><img src="\image\1.png" alt="avatar"></p><pre><code>从图中我们可以看出,变量a所能引用的属性只有A中的属性，B中的属性不出现在a可以引用的列表中此即属性是（静态）绑定到对象变量上的</code></pre><p><img src="\image\2.png" alt="avatar"></p><pre><code>从图中我们可以看出，此时类B重写了方法printS();执行过程如下啊：编译时，引用的是A中的printS();但在运行时，发现B中重写了方法,于是就用B中的方法覆盖了A中的方法。如下：</code></pre><p><img src="\image\3.png" alt="avatar"></p><pre><code>此即方法时动态绑定到对象上的。如若想引用B类中的属性，该如何操作呢？见下图：将a强制转换为B类型即可。</code></pre><p><img src="\image\4.png" alt="avatar"></p><pre><code>但是我们会发现</code></pre><p><img src="\image\5.png" alt="avatar"></p><pre><code>强制转换为C类型也不会报错，这是因为在编译期间，编译器只检查语法错误。现在我们运行一下：</code></pre><p><img src="\image\6.png" alt="avatar"></p><pre><code>发现报了ClassCastException错误。为了避免类似的错误发生我们使用如下方法进行改善代码：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Coo();</span><br><span class="line">      if(a instanceof Boo)&#123;</span><br><span class="line">            Boo  b = (Boo)a; </span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><pre><code>instanceof就是判断变量所指的对象是不是某一类型。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;多态之向上造型类型&quot;&gt;&lt;a href=&quot;#多态之向上造型类型&quot; class=&quot;headerlink&quot; title=&quot;多态之向上造型类型&quot;&gt;&lt;/a&gt;多态之向上造型类型&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;解释：
`属性是绑定到变量上（只能调用父类中有的属性），重写方法是动
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>java_01</title>
    <link href="http://yoursite.com/2018/04/18/java-01/"/>
    <id>http://yoursite.com/2018/04/18/java-01/</id>
    <published>2018-04-17T16:16:14.000Z</published>
    <updated>2018-05-01T14:04:31.172Z</updated>
    
    <content type="html"><![CDATA[<h1 id="面向对象的特征（后续会贴详细代码）"><a href="#面向对象的特征（后续会贴详细代码）" class="headerlink" title="面向对象的特征（后续会贴详细代码）"></a>面向对象的特征（后续会贴详细代码）</h1><pre><code>面向对象有三大特征：继承，封装，多态。今天我就来详细介绍一下面向对象这三个特征，着重记一下各个特征的优缺点</code></pre><h2 id="继承："><a href="#继承：" class="headerlink" title="继承："></a>继承：</h2><pre><code>java语言支持单继承，一个类可以继承一个父类这样，父类里的方法及属性，被子类继承，有利于程序的功能扩展为了开发方便好处：可以不用修改一个类，利用继承的特点，可以扩展这个类，生成一个子类，有利于二次开发优点：增加代码重用性，有利于类的功能扩展，也保证了父类的安全性</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public class new A()&#123;</span><br><span class="line">    public A()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装："><a href="#封装：" class="headerlink" title="封装："></a>封装：</h2><pre><code>将属性/方法封装到类里，将一段逻辑封装到方法里好处：提高代码的重用性，减少冗余，减少代码的可见性，相对安全</code></pre><h2 id="多态："><a href="#多态：" class="headerlink" title="多态："></a>多态：</h2><pre><code>对象的多态：不同父类型的引用指向同一个对象，会有不同的行为功能变量的多态：同一个变量指向不同的对象时，会有不同的行为好处:在使用代码时更方便，有利于程序的修改</code></pre><h3 id="向上造型"><a href="#向上造型" class="headerlink" title="向上造型"></a>向上造型</h3><pre><code>父类型的变量指向子类型的对象在编译期间，变量调用的方法是父类型中的。在运行期间, 如果调用的方法子类重写了，那么一定是重写后的方法如果没重写，那么调用的是父类中的方法变量调用的属性：一定是父类中的属性 总结：`属性是绑定到变量上（只能调用父类中有的属性），重写方法是动态绑定到对象上`。属性看变量类型，方法看对象类型向下转型：将父类型的变量，转换子类型的变量</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Boo();//a是变量，Book（）是对象</span><br><span class="line">Boo  b = (Boo)a;</span><br></pre></td></tr></table></figure><p>有可能会出现ClassCastException:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Coo();</span><br><span class="line">Boo  b = (Boo)a;</span><br></pre></td></tr></table></figure></p><p>编译期间：javac.exe只检查代码的语法是否正确。<br>此处语法虽然正确，但是a的类型并不是<br>为了避免这种情况发生，需要使用 instanceof进行判断，<br>判断变量所指的对象是不是某一类型。<br>上述代码应该改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Aoo  a = new Coo();</span><br><span class="line">if(a instanceof Boo)&#123;</span><br><span class="line">    Boo  b = (Boo)a; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;面向对象的特征（后续会贴详细代码）&quot;&gt;&lt;a href=&quot;#面向对象的特征（后续会贴详细代码）&quot; class=&quot;headerlink&quot; title=&quot;面向对象的特征（后续会贴详细代码）&quot;&gt;&lt;/a&gt;面向对象的特征（后续会贴详细代码）&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;面向
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
  </entry>
  
</feed>
